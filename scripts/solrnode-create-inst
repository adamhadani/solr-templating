#!/usr/bin/env python
#
#  Licensed under the Apache License, Version 2.0 (the "License"); 
#  you may not use this file except in compliance with the License. 
#  You may obtain a copy of the License at 
#  
#      http://www.apache.org/licenses/LICENSE-2.0 
#     
#  Unless required by applicable law or agreed to in writing, software 
#  distributed under the License is distributed on an "AS IS" BASIS, 
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
#  See the License for the specific language governing permissions and 
#  limitations under the License. 
#
"""Create a runnable instance from given template directory / package file (.tgz)"""

import os
import sys
import glob
import shutil
import fnmatch
import tarfile
import logging
from contextlib import closing
from optparse import OptionParser

from jinja2 import Template


def render_templates(inst_dir, env):
    """Walk over instance dir, and render every .tmpl file into
    target file, interpolating environment as needed"""
    for root, dirnames, filenames in os.walk(inst_dir):
        for filename in fnmatch.filter(filenames, '*.tmpl'):
            with closing(open(os.path.join(root, filename), "r")) as ifh:
                with closing(open(os.path.join(root, filename[:-5]), "w")) as ofh:
                    logging.debug("Rendering template '%s'", filename)
                    Template(ifh.read()).stream(**env).dump(ofh)
            os.remove(os.path.join(root, filename))

def instance_from_tmpl_dir(tmpl_dir, instance):
    """Create instance directory given template directory
    and enviroment (key, value) tuples to interpolate"""
    try:
        shutil.copytree(tmpl_dir, instance)
    except OSError:
        logging.error("Directory '%s' already exists. Remove it first to create instance.", instance)
        sys.exit(1)
    else:
        return instance


def parse_args():
    usage = "%prog -t <template_name_or_dir_or_tgz> -i <instance_name> tomcat.port=<port> [env_var=<value> ...]"
    parser = OptionParser(usage=usage)
    parser.add_option("-t", "--template", dest="template",
        help="Template to use for creating instance. Can be template name, path to template dir, or .tgz package containing template")
    parser.add_option("-i", "--instance", dest="instance",
        help="Instance name to be created")
    parser.add_option("-f", "--force", dest="force", action="store_true", default=False,
        help="Force creation of new instance, even if directory exists")

    options, args = parser.parse_args()
    
    if not options.template or not options.instance:
        parser.error("Must supply valid template name and name of instance to create. Use -h for usage instructions.")

    return parser, (options, args)


def main():
    parser, (options, args) = parse_args()
   
    # Parse environment variables given
    env = dict(map(lambda x: x.split("="), args))
    env['tomcat'] = {'port': '8081', 'shutdown_port': '18081'}
    env['fs'] = {'solr_home': '/usr/local/solr', 'solr_war_file': '/usr/local/solr/solr.war'}

    if os.path.isdir(options.instance) and options.force:
        logging.warn("Directory '%s' already exists and --force flag given, purging existing directory", 
            options.instance)
        shutil.rmtree(options.instance)

    if os.path.isdir(options.template):
        # Template is a directory in local fs
        instance_from_tmpl_dir(options.template, options.instance)

    elif os.path.exists(options.template):
        # Template given is a file, verify valid package
        if not options.template.endswith('.tgz') and \
          not options.template.endswith('.tar.gz'):
            parser.error("Invalid package file. Packages must be valid .tar.gz files.")

    else:
        # Check if template name exists in global template repository
        parser.error("Must supply valid template name. Use -h for usage instructions.")

    logging.info("Rendering templates in instance directory...")
    render_templates(options.instance, env)

    logging.info("All done.")


if __name__ == "__main__":
    sys.exit(main())

